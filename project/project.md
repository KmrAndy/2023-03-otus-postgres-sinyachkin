#Проектная работа
## Архивация данных с использованием партиционионированных таблиц

### Краткое описание:
В проектной работе создан механизм, который умеет:
- создавать новые партиции у таблиц
- переносить партицию из основной таблицы в архивную таблицу
- выгружать данные из архивной таблицы в архивную БД
- удалять старые партиции таблиц

### Основные объекты:
1) Настроечная таблица для создания партиций таблиц *project_schema.create_table_partitions*.
Поля таблицы:
```
    table_owner               - схема таблицы
    table_name                - имя таблицы
    stored_partition_quantity - количество партиций, которые должны быть у таблицы
    enabled                   - флаг включения механизма для таблицы
    search_type               - метод поиска партиций (1 - ищем будущие вместе с текущей, 2 - ищем все)
    partition_interval        - интервал партиционирования ('DAY' - ежедневно, 'MONTH' - ежемесячно, 'YEAR' - ежегодно)
```

2) Настроечная таблица для архивации партиций таблиц *project_schema.archive_table_partitions*.
Поля таблицы:
```
    table_owner               - схема таблицы
    table_name                - имя таблицы
    archive_table_name        - имя архивной таблицы
    stored_partition_quantity - количество партиций, которые должны быть у таблицы
    enabled                   - флаг включения механизма для таблицы
    search_type               - метод поиска партиций (1 - ищем прошлые от текущей(текущая не считается), 2 - ищем все)
```
3) Настроечная таблица для архивации партиций таблиц *project_schema.drop_table_partitions*.
Поля таблицы:
```
    table_owner               - схема таблицы
    table_name                - имя таблицы
    stored_partition_quantity - количество партиций, которые должны быть у таблицы
    enabled                   - флаг включения механизма для таблицы
    search_type               - метод поиска партиций (11 - ищем прошлые от текущей(текущая не считается), 2 - ищем все)
```
4) Таблица логов *project_schema.logs*.
Поля таблицы:
```
    log_id      - уникальный ID записи
    log_date    - время добавления записи
    username    - имя пользователя, добавившего запись
    pid         - уникальный ID сессии
    message     - сообщение
    stacktrace  - стек вызовов до ошибки, если нужно
```
5) Таблица параметров *project_schema.parameters*.
Поля таблицы:
```
    module - модуль параметра
    param  - имя параметра
    value  - значение параметра
```
6) Очередь для переноса данных из архивной таблицы в архивную БД *project_schema.archiever_queue*.
Поля таблицы:
```
    id             - уникальный ID записи
    queue_date     - дата вставки в очередь
    table_owner    - схема таблицы
    table_name     - имя таблицы
    partition_name - имя партиции таблицы
    process_flag   - флаг необходимости переноса данных
    process_date   - дата переноса данных
```
7) Функция *maintenance_schema.get_table_partitions* - возвращает параметры партиций таблиц по переданному имени таблицы
8) Функция *maintenance_schema.get_tables_diff_columns* - возвращает количество отличающихся полей между двумя таблицами
9) Процедура *maintenance_schema.archive_old_table_partitions* - архивирует старые партиции всех таблиц, согласно настройкам в *project_schema.archive_table_partitions*
10) Процедура *maintenance_schema.create_new_table_partitions* - создает новые партиции у всех таблиц, согласно настройкам в *project_schema.create_table_partitions*
11) Процедура *maintenance_schema.drop_old_table_partitions* - удаляет новые партиции у всех таблиц, согласно настройкам в *project_schema.create_table_partitions*

### Ограничения
Механизмы на данном этапе умеют работать только с RANGE и LIST партиционированными таблицами.

Ограничения для RANGE партиционированных таблиц:
- Ключом партиции может быть только дата

Ограничения для LIST партиционированных таблиц с ключом от даты:
- LIST ключ партиции должен иметь только одно значение, принимающее формат даты YYYYMMDD.
- Для ежедневных партиций значение ключа равно дате: 20230203 - 3 февраля 2023 года.
- Для ежемесячных партиций значение ключа равно дате последнего дня месяца: 20230331 - март 2023 года.
- Для ежегодных партиций значение ключа равно дате последнего дня года: 20231231 - 2023 год.

На LIST партиционированные таблицы, у которых ключ монотонно возрастает, ограничения не распространяются, но метод поиска партиций для таких таблиц должен быть 2.

Ограничения на PK-FK:
Если у таблицы есть первичный ключ, на который ссылается внешний ключ дочерней таблицы, то для такой таблицы нужно делать отключение ключа у дочерней таблицы перед операцией у родительской, затем включение обратно без валидации.
Такое поведение в данной проектной работе не закладывалось, но будет сделано в дальнейшем.

### Описание механизма архивации партиций таблиц
Механизм архивации состоит из 2 компонентов.
*Внутренний*: ищет старые партиции, пригодные для архивации, переносит их из основной таблицы в архивную, включая индексы
*Внешний*: выгружает данные из архивной таблицы в архивную БД

Имя архивной таблицы должно обязательно начинаться с префикса *arch_*.
Cтруктура родительской основной таблицы и родительской архивной таблицы должны сопадать полность, кроме имени таблицы.
Структура таблиц между основной БД и архивной БД аналогично должны совпадать, включая имя таблицы.

### Описание механизма удаления партиций таблиц
Механизм удаляет старые партиции из таблицы, тем самым освобождая место в БД.
Умеет очищать архивные таблицы, но только после того, как данные из партиции архивной таблицы были выгружены в архивную БД.

### Описание механизма удаления партиций таблиц
Механизм следит за тем, чтобы у таблицы всегда было достаточное количество будущих партиций.
Создает новые партиции у таблицы, если количество будущих партиций, стало меньше ожидаемого.
Подбор табличного пространства для новой партиции осуществляется путём получения табличного пространства от последней существующей партиции

Ограничения:
- Пока что не умеет работать с субпартиционированными таблицами.
- Работа с ежемесяыными табличными пространствами пока что ограничена форматом *tblspaceYYYYMM* на время проекта. В дальнейшем маска табличного пространства будет настраиваемой.

### Установка
1) Создать схемы *project_schema* и *maintenance_schema* в основной БД (project_main_db), схем *project_schema* в архивной БД (project_archive_db)
2) Для проверки правильного выбора табличных пространств можно создать несколько, как в примере *scripts/script1.sql*
3) Установить все объекты из папки *objects*. Порядок установки: *types*, *sequences*, *tables*, *functions*, *procedures*
4) Заполнить настроечные таблицы с помощью *scripts/script2.sql*, при желании со значениями можно поэкспериментировать
5) Наполнить таблицы для теста данными, чтобы удостовериться в корректности переноса при архивации - *scripts/script3.sql*
6) На ВМ для архивной БД создать папку *archiever_log* (у меня путь был такой /var/lib/postgresql/15/arch/archiever_log/).
Прописать этот путь в *scrips/archiever_bash_script.sh*
7) При желании можно настроить cron (у меня запускался каждые 10 минут для теста), а можно запускать скрипт *scrips/archiever_bash_script.sh* вручную, после прогона архивации партиций в основной БД.

### Запуск
1) Запуск механизмов происходит в первом блоке скрипта *scripts/examples.sql*
2) Наблюдать за ходом работы механизмов можно по таблице *project_schema.logs*
